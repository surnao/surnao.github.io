{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://surbao.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-06-06T08:44:13.132Z","updated":"2024-06-06T08:44:13.132Z","comments":false,"path":"/404.html","permalink":"https://surbao.top/404.html","excerpt":"","text":""},{"title":"书单","date":"2024-06-06T09:07:52.481Z","updated":"2024-06-06T09:07:52.481Z","comments":false,"path":"books/index.html","permalink":"https://surbao.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-06-06T08:57:41.413Z","updated":"2024-06-06T08:57:41.413Z","comments":true,"path":"links/index.html","permalink":"https://surbao.top/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-06-06T08:44:13.132Z","updated":"2024-06-06T08:44:13.132Z","comments":false,"path":"about/index.html","permalink":"https://surbao.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2024-06-06T08:44:13.133Z","updated":"2024-06-06T08:44:13.133Z","comments":false,"path":"categories/index.html","permalink":"https://surbao.top/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-06-06T08:44:13.134Z","updated":"2024-06-06T08:44:13.134Z","comments":false,"path":"repository/index.html","permalink":"https://surbao.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-06-07T02:49:32.197Z","updated":"2024-06-07T02:49:32.197Z","comments":false,"path":"tags/index.html","permalink":"https://surbao.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"sort排序","slug":"sort排序","date":"2024-06-07T06:21:48.138Z","updated":"2024-06-07T06:26:13.862Z","comments":true,"path":"2024/06/07/sort排序/","permalink":"https://surbao.top/2024/06/07/sort%E6%8E%92%E5%BA%8F/","excerpt":"","text":"定义及用法sort() 方法用于对数组的元素进行排序，并返回数组。排序顺序可以是按字母或数字，也可以是升序（向上）或降序（向下）。默认排序顺序是根据字符串UniCode码。 语法：Array.sort(sortBy); 参数sortBy可选，用来规定排序的顺序，但必须是函数。 例1在数组中的值为number​类型时，结果并不是和正常排序一样，而是字符编码的出现顺序排列的。 12var arr = [2, 6, 8, 8, 2, 10]console.log(arr.sort()) //[ 10, 2, 2, 6, 8, 8 ] 如要得到想要的结果，不管是升序还是降序，就需要提供比较函数了。该函数比较两个值的大小，然后返回一个用于说明这两个值的相对顺序的数字。 比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。 若 a 等于 b，则返回零。 若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。 例2 升序排列12345var arr = [2, 6, 8, 8, 2, 10] arr.sort((a, b) =&gt; &#123; return a - b &#125;)console.log(arr)//[2, 2, 6, 8, 8, 10] 例3 降序排列12345var arr = [2, 6, 8, 8, 2, 10] arr.sort((a, b) =&gt; &#123; return b - a &#125;)console.log(arr)//[ 10, 8, 8, 6, 2, 2 ] 追根究底，a指什么？b指什么？内部用怎样的方法实现的排序？ 首先改变数组，看一下a指的到底是什么 1234567891011var arr = [6, 8, 2, 10, 1] arr.sort((a, b) =&gt; &#123; console.log(&quot;a:&quot; + a) return 1&#125;)console.log(arr)//a:8//a:2//a:10//a:1//[6, 8, 2, 10, 1] 很容易看出a的范围是[arr[1],arr[arr.length-1]]​.另外能看出当函数返回一个正值时，数组并没有发生变化（0也是） 接下来再看一下b指的是什么 1234567891011var arr = [6, 8, 2, 10, 1] arr.sort((a, b) =&gt; &#123; console.log(&quot;b:&quot; + b) return -1&#125;)console.log(arr)//b:6//b:8//b:2//b:10//[1, 10, 2, 8, 6] b的范围[arr[0],arr[arr.length-2]​，另外在这里还获得一个使数组反序的方法（另外一个是数组的reverse()​方法） a和b的范围就这样被简单的确定了，但在真正排序的时候就不是这样简单了 123456789101112131415161718192021222324252627282930313233343536var arr = [6, 8, 2, 10, 1] arr.sort((a, b) =&gt; &#123; console.log(&quot;b:&quot; + b) console.log(&quot;a:&quot; + a) console.log(&quot;------&quot;) return a - b&#125;)console.log(arr)//b:6//a:8//------//b:8//a:2//------//b:8//a:2//------//b:6//a:2//------//b:6//a:10//------//b:8//a:10//------//b:8//a:1//------//b:6//a:1//------//b:2//a:1//------//[1, 2, 6, 8, 10] 先把数据整理一下 12345//[6, 8, 2, 10, 1][&#123; b: 6, a: 8 &#125;],[&#123; b: 8, a: 2 &#125;, &#123; b: 8, a: 2 &#125;, &#123; b: 6, a: 2 &#125;],[&#123; b: 6, a: 10 &#125;, &#123; b: 8, a: 10 &#125;],[&#123; b: 8, a: 1 &#125;, &#123; b: 6, a: 1 &#125;, &#123; b: 2, a: 1 &#125;], 通过测试以及研究源码v8源码sort部分可得出结论，如果要排序的元素个数是 n​的时候，会有以下几种情况： 当 n&lt;=10​时，采用插入排序； 当10&lt;n&lt;=1000​时，采用中位数作为哨兵元素； 当n&gt;1000​，每隔200~215​个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。 按照数组对象的某个属性排序例4现在有一组对象，包含”id，value”等属性，实现按照value对这些对象进行排序。 12345678910111213141516var arr = [ &#123; id: &#x27;1&#x27;, value: 100 &#125;, &#123; id: &#x27;2&#x27;, value: 120 &#125;, &#123; id: &#x27;3&#x27;, value: 80 &#125;, &#123; id: &#x27;4&#x27;, value: 90 &#125;, &#123; id: &#x27;5&#x27;, value: 130 &#125;]arr.sort(function sortBy(a, b) &#123; return a.value - b.value;&#125;)console.log(arr)//&#123;id: &#x27;3&#x27;, value: 80&#125;//&#123;id: &#x27;4&#x27;, value: 90&#125;//&#123;id: &#x27;1&#x27;, value: 100&#125;//&#123;id: &#x27;2&#x27;, value: 120&#125;//&#123;id: &#x27;5&#x27;, value: 130&#125; 假如现在不规定按照哪一个属性排序，比如除了value属性，还有其他的属性 12345678910111213141516171819var arr = [ &#123; id: &#x27;1&#x27;, value: 100 &#125;, &#123; id: &#x27;2&#x27;, value: 120 &#125;, &#123; id: &#x27;3&#x27;, value: 80 &#125;, &#123; id: &#x27;4&#x27;, value: 90 &#125;, &#123; id: &#x27;5&#x27;, value: 130 &#125;]function sortBy(props) &#123; return function(a,b) &#123; return a[props] - b[props]; &#125;&#125;arr.sort(sortBy(&quot;value&quot;));console.log(arr)//&#123;id: &#x27;3&#x27;, value: 80&#125;//&#123;id: &#x27;4&#x27;, value: 90&#125;//&#123;id: &#x27;1&#x27;, value: 100&#125;//&#123;id: &#x27;2&#x27;, value: 120&#125;//&#123;id: &#x27;5&#x27;, value: 130&#125; 假如value相等的情况下，是否可以按照其他属性的大小排序输出 12345678910111213141516171819var arr = [ &#123; id: &#x27;1&#x27;, value: 100 &#125;, &#123; id: &#x27;2&#x27;, value: 120 &#125;, &#123; id: &#x27;4&#x27;, value: 80 &#125;, &#123; id: &#x27;3&#x27;, value: 80 &#125;, &#123; id: &#x27;5&#x27;, value: 130 &#125;]function sortBy(val1,val2) &#123; return function(a,b) &#123; if(a.val1== b.val1) return a.val2- b.val2; return a.val1- b.val1; &#125;&#125;arr.sort(sortBy(&quot;value&quot;,&quot;id&quot;));//&#123;id: &#x27;3&#x27;, value: 80&#125;//&#123;id: &#x27;4&#x27;, value: 80&#125;//&#123;id: &#x27;1&#x27;, value: 100&#125;//&#123;id: &#x27;2&#x27;, value: 120&#125;//&#123;id: &#x27;5&#x27;, value: 130&#125; 如此，即可实现，甚至可以使用argments来获取更多的参数，用以传入更多的字段作为判断条件。 总结 ​sort()​方法没有参数时，按照字符的Unicode进行排序（把数组里面当成字符串处理） 通过给sort()​的参数返回一个负值可以实现数组reverse()​效果 ​sort()​ 参数返回 a - b​时，数组是升序，返回-(a - b)​ 即b - a​时，数组是降序 ‍","categories":[{"name":"JS","slug":"JS","permalink":"https://surbao.top/categories/JS/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://surbao.top/tags/sort/"}]},{"title":"cookie、sessionStorage 和 localStorage","slug":"cookie、sessionStorage 和 localStorage","date":"2024-06-07T06:15:10.305Z","updated":"2024-06-07T06:20:27.250Z","comments":true,"path":"2024/06/07/cookie、sessionStorage 和 localStorage/","permalink":"https://surbao.top/2024/06/07/cookie%E3%80%81sessionStorage%20%E5%92%8C%20localStorage/","excerpt":"","text":"cookie1.基本概念Cookie是保存在计算机上的一种文件。当我们使用计算机浏览网页时，服务器会生成一个证书并将其返回给我们的计算机。这个证书就是cookie。一般来说，cookie是服务器写给客户端的文件，也可以称为浏览器缓存。 简单来说，它可以读取并保存你访问网站时产生的一些行为信息，这些信息通常是加密的，否则会侵犯用户的隐私。Cookie也可以帮助加快第二次访问。通常，当我们访问一些网页时，系统会提示我们是否要保存用户名和密码。下次登录时，我们可以自动登录，无需再次登录。​ 2.用法1234//引入js-cookie.js1.直接引用cdn：&lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;2.本地下载下来后：&lt;script src=&quot;/plugins/js.cookie.js&quot;&gt;&lt;/script&gt;3.模块化开发时: npm install js-cookie import Cookies from &#x27;js-cookie&#x27; 12345678910111213141516171819202122232425262728//使用// 写入cookieCookies.set(&#x27;name&#x27;, &#x27;value&#x27;);// 读取cookieCookies.get(&#x27;name&#x27;); //&#x27;value&#x27;// 读取所有可见的cookieCookies.get();//&#123;name: &#x27;value&#x27;&#125;// 删除某项cookie值Cookies.remove(&#x27;name&#x27;);//cookie的set方法支持的属性有：//expires-&gt;过期时间//path-&gt;设置为指定页面创建cookie//domain-&gt;设置对指定域名及指定域名的子域名可见//secure-&gt;设置是否只支持https,默认是falseCookies.set(&#x27;key&#x27;, &#x27;value&#x27;); //创建简单的cookieCookies.set(&#x27;key&#x27;, &#x27;value&#x27;, &#123; expires: 27 &#125;);//创建有效期为27天的cookieCookies.set(&#x27;key&#x27;, &#x27;value&#x27;, &#123; expires: 17, path: &#x27;/userInfo&#x27; &#125;); //为userInfo页创建有效期17天的cookie//删除指定页面path的cookieCookies.remove(&#x27;key&#x27;, &#123; path: &#x27;&#x27; &#125;);//注：如果存的是对象,如:const userInfo = &#123;age : 111, score : 90&#125;;Cookies.set(&#x27;userInfo&#x27;, userInfo);//取出来的userInfo需要进行JSON的解析,解析为对象const userInfo = JSON.parse( Cookies.get(&#x27;userInfo&#x27;) );//也可以使用Cookies.getJSON(&#x27;userInfo&#x27;); 3.生命周期与优缺点12//创建Cookie时指定的expires值，就是Cookie的生存周期，在这个周期内Cookie有效，超出周期Cookie就会被清除。//注：Cookie的生存周期设置为 &#x27;0&#x27;或负值, 在关闭浏览器时，就会马上清除Cookie。 优点 Cookie易于使用和实现 实现cookie的使用要比任何其他Internet协议容易得多。 占用更少的内存 不需要任何服务器资源，并存储在用户的计算机上，因此不会给服务器带来额外的负担。 持久性 当在客户端的浏览器上设置Cookie时，它可以持续数天，数月甚至数年。这样可以轻松保存用户首选项和访问信息，并在用户每次返回站点时保持此信息可用。此外，由于Cookie存储在客户端的硬盘上，因此如果服务器崩溃，它们仍然可用。 缺点 不安全 cookie是以明文形式存储，可能会造成安全风险，因为任何人都可以打开并篡改cookie。 数量受到限制 浏览器能创建的 Cookie 数量最多为 300​ 个，并且每个不能超过 4KB​，每个 Web 站点能设置的 Cookie 总数不能超过 20 个。 可以被禁用 用户可以选择从浏览器设置中禁用其计算机上的cookie。这意味着用户可以决定不在他的浏览器上使用cookie，这可能会使程序在浏览器的运行中产生一些问题。 SessionStorage和localStorage1.基本概念浏览器提供的本地存储机制 2.用法1234567891011121314151617181920//它们的 API 基本相同,包括:// setItem(key, value): 存储数据// getItem(key): 获取数据// removeItem(key): 删除数据// clear(): 清空所有存储的数据// key(i): 获取第 i 个键名// length: 获取存储的数据个数// 存储数据sessionStorage.setItem(&quot;key1&quot;, &quot;value1&quot;);localStorage.setItem(&quot;key2&quot;, &quot;value2&quot;);// 获取数据const value1 = sessionStorage.getItem(&quot;key1&quot;);const value2 = localStorage.getItem(&quot;key2&quot;);// 删除数据sessionStorage.removeItem(&quot;key1&quot;);localStorage.removeItem(&quot;key2&quot;);// 清空存储sessionStorage.clear(); localStorage.clear(); 3.生命周期与优缺点 sessionStorage 只在当前浏览器标签页有效,关闭标签页即失效。localStorage 永久有效,除非主动删除。 localStorage 优点: 数据持久存储。除非主动删除,否则一直存在。 可以保存结构化数据,如对象、数组。 localStorage 缺点: 不能存储敏感数据,因为数据可以被恶意获取。 可能导致本地存储空间被占用过多。 sessionStorage 优点: 数据临时存储,会话结束自动删除,不会占用过多本地存储空间。 可以在同一个会话的不同页面中共享数据。 sessionStorage 缺点: 数据不持久,会话结束随之删除。 不能保存敏感数据,数据只在客户端,容易被获取。 三者异同 特性 Cookie localStorage sessionStorage 数据的生命周期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 存储类型 只能存储字符串 可以存储字符串、布尔值、整数、浮点数、对象、数组等 作用域 在同源的窗口&#x2F;标签页之间共享 典型使用场景 保存用户登录状态、购物车信息等 长期保存键值对数据,比如用户偏好设置或浏览历史 保存一个会话的信息,在用户登出或浏览器关闭之前一直存在 ‍","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://surbao.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://surbao.top/tags/%E7%BC%93%E5%AD%98/"}]}],"categories":[{"name":"JS","slug":"JS","permalink":"https://surbao.top/categories/JS/"},{"name":"浏览器","slug":"浏览器","permalink":"https://surbao.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://surbao.top/tags/sort/"},{"name":"缓存","slug":"缓存","permalink":"https://surbao.top/tags/%E7%BC%93%E5%AD%98/"}]}